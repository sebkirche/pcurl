#!/usr/bin/env perl

# pCurl - a cURL-like implemented in Perl
#         with custom features like STOMP message sending
#         or response processing
#
# (c) 2019, 2020 - Sébastien Kirche

use warnings;
use strict;
use feature 'say';
use utf8;
use open ':std', ':encoding(UTF-8)';
use Data::Dumper;
use Getopt::Long qw(:config no_ignore_case bundling); # debug
use IO::Select;
use IO::Socket::INET;
use IPC::Open3;
use MIME::Base64 'encode_base64';
use Pod::Usage;
use Socket qw(IPPROTO_TCP TCP_NODELAY);
use Time::Local;
# use Carp::Always;

our $VERSION = '0.7.6';
$|++; # auto flush messages

$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Indent   = 2;

# -------- Signal handlers -------------------------
BEGIN{                          # automagic breakpoint for warnings when script is run by perl -d
    $SIG{__WARN__} = sub {
        my $msg = shift;
        chomp $msg;
        say STDERR "Warning: '$msg'";
        no warnings 'once';     # avoid « Warning: 'Name "DB::single" used only once: possible typo »
        $DB::single = 1;        # we stop execution if a warning occurs during run
    };
}
$SIG{INT}  = sub { say STDERR "SIGINT / CTRL-C received (Interrupt from keyboard). Leaving."; exit };
$SIG{QUIT} = sub { say STDERR "SIGQUIT / CTRL-\\ received (Quit from keyboard). Leaving."; exit };
$SIG{ABRT} = sub { say STDERR "SIGABRT received (Probable abnormal process termination requested by a library). Leaving."; exit };
$SIG{TERM} = sub { say STDERR "SIGTERM received - External termination request. Leaving."; exit };
sub suspend_trap {
    say STDERR "SIGTSTP / CTRL-Z received. Suspending...";
    $SIG{TSTP} = 'DEFAULT';
    kill 'TSTP', -(getpgrp $$);
}
$SIG{TSTP} = \&suspend_trap;
$SIG{CONT} = sub { $SIG{TSTP} = \&suspend_trap; say STDERR "SIGCONT received - continue after suspension." };
# --------------------------------------------------

my $max_redirs = 50;            # default value for maximum redirects to follow
my $def_max_wait = 10;          # default value for response timeout
my %defports = ( http  => 80,
                 https => 443 );

my ($url, $cli_url, $uagent, $http_vers, $tunnel_pid, $auto_ref, $use_cookies, $cookies, $process_action);
my %args = ( 'tcp-nodelay' => 1, 'data-urlencode' => [], header => []  );

GetOptions(\%args,
    'accept=s',             
    'action=s',             
    'basic=s',              
    'content=s',            
    'cookie|b=s',           
    'cookie-jar|c=s',       
    'data-binary=s',        
    'data-raw=s',           
    'data-urlencode=s@',    
    'data|data-ascii|d=s',  
    'debug',                
    'debug-json=s',         
    'debug-json-export',    
    'header|H=s@',
    'head|I',
    'help|h|?',
    'http09',
    'http10',
    'http11',
    'include-response|include|i',
    'include-request',
    'junk-session-cookies',
    'location|L',
    'man',
    'max-wait=i',
    'max-redirs=i',
    'noproxy=s',
    'output|o=s',
    'parse-only',               # just show how we parse the URL
    'port|p=i',
    'proxy-user|U=s',
    'proxy10=s',
    'proxy|x=s',
    'remote-name|O',
    'referer|e=s',
    'request|X=s',
    # 'stompdest=s',
    'stompmsg=s',
    'tcp-nodelay!',             # negatable: --notcp-nodelay
    'url=s',
    'user-agent|A=s',
    'verbose|v',
    ) or pod2usage(-exitval => 2, -verbose => 0);
pod2usage(-exitval => 0, -verbose => 1) if $args{help};
pod2usage(-exitval => 0, -verbose => 2) if $args{man};

if ($args{'debug-json'}){
    say STDERR "Testing JSON parser...";
    if ($args{'debug-json'} eq '-'){
        my @lines = <STDIN>;
        $args{'debug-json'} = join '', @lines;
    } elsif (-r $args{'debug-json'}){
        open (my $fh, '<', $args{'debug-json'}) or die "Cannot open $args{'debug-json'}: $!";
        local $/;
        $args{'debug-json'} = <$fh>;
        close $fh;
    }
    say STDERR "Reading done. Parsing...";
    my $obj = from_json($args{'debug-json'});
    say STDERR "Parsing done. Dumping...";
    if ($args{'debug-json-export'}){
        say to_json($obj);
    } else {
        say Data::Dumper->Dump([$obj],[ 'json' ]);
    }
    exit 0;
}

# User-Agent
$uagent = $args{'user-agent'} || "pCurl/$VERSION";

# Referer provided, or auto-referer?
# auto-referer is: take the url of the previous url as referer when following redirects 
if ($args{referer} && $args{referer} =~ /([^;]*)?;auto/){
    $auto_ref = 1;
    $args{referer} = $1;
}

# Cookies
if ($args{cookie} || $args{'cookie-jar'}){
    $use_cookies = 1;
    if ($args{cookie}){
        if (-f $args{cookie}){
            $cookies = load_cookie_jar($args{cookie});
            say STDERR "Cookies from jar:", Dumper $cookies if $args{debug};
            if ($args{'junk-session-cookies'}){
                # keep cookies with expiration (if not it's a session cookie)
                $cookies = [ grep { $_->{expires} } @$cookies ];
            }
        } else {
            $cookies = load_commandline_cookies($args{cookie});
            say STDERR "Cookies from command-line:", Dumper $cookies if $args{debug};
        }
    }
    # keep non-expired cookies
    my $now = time;
    $cookies = [ grep { !$_->{expires} || ($_->{expires} >= $now) } @$cookies ];
    say STDERR "Cookies from jar after purge and expiration:", Dumper $cookies if $args{debug};
}

# shortcut to -H 'Accept: mime'
if ($args{accept}){
    push @{$args{header}}, "Accept: $args{accept}";
}

# Action is either a specific value to extract from the result (header, json field)
# an can be more sophisticated actions
if ($args{action}){
    $process_action = parse_process_action($args{action});
}

$cli_url = $args{url} || $ARGV[0];
unless ($cli_url){
    say STDERR "No url provided...";
    pod2usage(-exitval => 1);
}
unless ($url = parse_url($cli_url)){
    say STDERR "It's strange to me that `$cli_url` does not look like an url...";
    exit 1;
}
if ($args{'parse-only'}){
    if ($url){
        for my $k (sort grep { $url->{$_} } keys %$url){
            if (ref $url->{$k} eq 'HASH'){
                my $h = $url->{$k};
                say(STDOUT "$k:$_ = $h->{$_}") for sort keys %$h;
            } else {
                say STDOUT "$k = $url->{$k}";
            }
        }
        exit 0;
    } else {
        exit 1;
    }
}

# if we want to output in a file, redirect the initial STDOUT
my $STDOLD;
if ($args{'remote-name'}){
    if ($url->{path} =~ m{\/([^/]+)$}){
        $args{output} = $1;
    } else {
        say STDERR "Cannot get remote file name from url.";
        exit 7;
    }
}
if ($args{output}){
    open $STDOLD, '>&', STDOUT;
    open STDOUT, '>', $args{output} or die "Cannot open $args{output} for output.";
    # binmode(STDOUT, ":raw");
    # later, to restore STDOUT:
    # open (STDOUT, '>&', $STDOLD);
}

if ($url->{scheme} =~ /^http/){
    # HTTP or HTTPS

    # version
    if ($args{http09}){
        $http_vers = '0.9';
    } elsif ($args{http10}){
        $http_vers = '1.0';
    } elsif ($args{http11}){
        $http_vers = '1.1';
    } else {
        $http_vers = '1.0'; # default HTTP version when not specified
    }

    if ($args{request}){
        if ($args{request} =~ /^(GET|HEAD|POST|PUT|TRACE|OPTIONS|DELETE)$/i){
            $args{request} = uc $args{request};
            if ($args{request} ne 'GET' and HTTP09()){
                say STDERR "HTTP/0.9 only supports GET method.\n" ;
                exit 2;
            }
        } else {
            # Nothing, one can have a custom HTTP method
        }
    }

    my $method;
    if ($args{data} || @{$args{'data-urlencode'}} || $args{'data-binary'} || $args{'data-raw'}){
        $method = $args{request} || 'POST';
    } else {
        $method = $args{head} ? 'HEAD' : $args{request} || 'GET';
    }
    #$url->{path} = '*' if $method eq 'OPTIONS';    
    process_http($method, $url);
} elsif ($url->{scheme} =~ /^stomp/){
    unless ($url->{path} && $args{stompmsg}){
        say STDERR "Message sending with --stompmsg <message> is supported for now.";
        exit 3;
    }
    process_stomp($url);
} elsif ($url->{scheme} eq 'file'){
    unless ( ! defined $url->{host}
             || lc($url->{host}) eq 'localhost'
             || $url->{host} eq '127.0.0.1'){
        say STDERR "* Invalid file://hostname/, expected localhost or 127.0.0.1 or none";
        exit 4;
    }
    process_file($url);
}

# save the cookie jar if requested
if ($args{'cookie-jar'}){
    save_cookie_jar($args{'cookie-jar'}, $cookies);
}

# close out file and restore STDOUT
if ($args{output}){
    close STDOUT;
    open (STDOUT, '>&', $STDOLD);
}

# ------- End of main prog ---------------------------------------------------------------

sub process_http {
    my $method = shift;
    my $url_final = shift;

    my ($IN, $OUT, $ERR, $host, $port, $resp);

    $max_redirs = $args{'max-redirs'} if defined $args{'max-redirs'};
    my $redirs = $max_redirs;   # redirs is a countdown of remaining allowed redirections
    do {
        say STDERR "* Processing url $url_final->{url}" if $args{verbose} || $args{debug};
        my $url_proxy = get_proxy_settings($url_final);
        my $pheaders = [];
        if ($url_proxy){
            $pheaders = build_http_proxy_headers($url_proxy, $url_final);
            $url_final->{proxified} = 1 if $url_final->{scheme} eq 'http';
            $url_final->{tunneled} = 1 if $url_final->{scheme} eq 'https';
        }

        # connect directly a socket to the server or to a proxy
        # or open a tunnel for HTTPS
        if ($url_proxy){
            ($OUT, $IN, $ERR) = connect_direct_socket($url_proxy->{host},
                                                      $url_proxy->{port}) if $url_final->{scheme} eq 'http';
            ($OUT, $IN, $ERR) = connect_ssl_tunnel($url_final, $url_proxy) if $url_final->{scheme} eq 'https';
        } else {
            ($OUT, $IN, $ERR) = connect_direct_socket($url_final->{host},
                                                      $url_final->{port}) if $url_final->{scheme} eq 'http';
            ($OUT, $IN, $ERR) = connect_ssl_tunnel($url_final) if $url_final->{scheme} eq 'https';
        }

        my $body = prepare_http_body_to_post();
        my $headers = build_http_request_headers($method, $url_final, $url_proxy, $body);
        if ($url_final->{proxified} && $pheaders){
            map { push @$headers, $_ } @$pheaders;
        }

        say STDERR "* Sending request to server" if $args{verbose} || $args{debug};

        # Write to the server
        send_http_request($IN, $OUT, $ERR, $headers, $body);
        
        # for some actions we need to capure the output
        my $need_capture = defined $process_action; # && $process_action->{action} eq 'grep';

        # Receive the response
        $resp = process_http_response($IN, $ERR, $url_final, $url_proxy, $need_capture);
        say STDERR Dumper $resp->{headers} if $args{debug};
        say STDERR "* received $resp->{byte_len} bytes" if $args{verbose} || $args{debug};
        if ($resp->{byte_len}){
            my $code = $resp->{status}{code};
            if ($args{location} && (300 <= $code) && ($code <= 399)){
                # if the result is a redirect, follow it
                unless($redirs){
                    say STDERR sprintf("* Maximum (%d) redirects followed", $max_redirs);
                    goto BREAK;
                }
                $args{referer} = $url_final->{url} if $auto_ref;      # use previous url as next referer
                my ($old_scheme, $old_host, $old_port) = ($url_final->{scheme}, $url_final->{host}, $url_final->{port});
                $url_final = parse_url($resp->{headers}{location}); # get redirected url
                # compare new url with previous and reconnected if needed
                if (($url_final->{scheme} ne $old_scheme) || ($url_final->{host} ne $old_host) || ($url_final->{port} != $old_port)){
                    say STDERR "* Closing connection because of scheme/server redirect" if $args{verbose} || $args{debug};
                    close $IN;
                    close $OUT;
                    close $ERR if $ERR;
                }
                say STDERR sprintf("* Redirecting #%d to %s", $max_redirs - $redirs,  $url_final->{url}) if $args{verbose} || $args{debug};
                $redirs--;
            } else {
                # result other than redirect

                if ($process_action){
                    perform_action($process_action, $resp);
                }
                
                goto BREAK;         # weird, 'last' is throwing a warning "Exiting subroutine via last"
            }
        }
    } while ($resp->{byte_len} && $url_final && $redirs >= 0);
  BREAK:
    
    close $IN;
    close $OUT;
    close $ERR if $ERR;
}

sub process_file {
    my $url = shift;
    my $path = $url->{path};
    my $content;
    my $resp = { headers => {} }; # simulate the network answer for action processing
    
    unless ( -r $path ){
        say STDERR "file $path seems not to exist";
        exit 6;
    }
    my $size = (stat $path)[7];
    say STDERR "* size of $path is $size" if $args{debug};
    $resp->{byte_len} = $size;
    open (my $fh, '<', $path) or die "Couldn't open file $path: $!";
    if (defined $process_action){
        local $/;
        $content = <$fh>;
        close $fh;
        $resp->{captured} = \$content;
        perform_action($process_action, $resp);
    } else {
        binmode $fh;
        my $buf = '';
        while (1){
            my $success = read($fh, $buf, 1024, length($buf));
            die $! if not defined $success;
            last if not $success;
            print STDOUT $buf;
        }
        close $fh;
    }
}

# transmission of headers + body to the server
sub send_http_request {
    my ($IN, $OUT, $ERR, $headers, $body) = @_;
    
    push @$headers, '';         # empty line to terminate request
    
    if ($args{verbose}){
        print STDERR "> $_\n" for @$headers;
    }
    my $headers_txt = join "", map { "$_\r\n" } @$headers;
    print $OUT $headers_txt;    # send headers to server
    print STDOUT $headers_txt if $args{'include-request'};

    if (defined $body){
        my $sent = 0;
        if (ref $body eq 'HASH'){
            if (exists $body->{data}){
                print $OUT $body->{data};
                $sent = $body->{size};
            } 
        } else {
            print $OUT $body if $body;
            $sent = length $body;
        }
        say STDERR "* upload completely sent off: $sent bytes" if $args{verbose} || $args{debug};
    }
    
    $OUT->flush;
    say STDERR "* HTTP request sent" if $args{debug};
}

# check if we need to connect to a proxy
# returns the address of the proxy, else undef
sub get_proxy_settings {
    my $url_final = shift;
    my $proxy;

    # if we match an explicit no_proxy argument or no_proxy environment, get out
    my $no_p = $args{noproxy} || $ENV{no_proxy};
    if ($no_p){
        $no_p =~ s/,/|/g;
        $no_p =~ s/\./\\./g;
        $no_p =~ s/\*/.*/g;
        if ($url_final->{host} =~ /$no_p/){
            return undef;
        }
    }
    
    my $proxy_set;
    if ($args{proxy}){
        $proxy_set = $args{proxy};
    } elsif ($args{proxy10}){
        $proxy_set = $args{proxy10};
    } elsif ($url_final->{scheme} eq 'http'){
        $proxy_set = $ENV{http_proxy};
    } elsif ($url_final->{scheme} eq 'https'){
        $proxy_set = $ENV{https_proxy};
    }
    return undef unless $proxy_set;
    
    $proxy = parse_url($proxy_set);
    unless ($proxy){
        say STDERR "It's strange to me that `$url` does not look as an url for proxy...";
        exit 4;
    }
    say STDERR "* Using proxy $proxy->{url}" if $args{verbose} || $args{debug};
    return $proxy;
}

# Construct the Request headers using
# - HTTP method
# - url we want
# - url for the proxy
# - the body (if any, to compute length and content-type)
sub build_http_request_headers {
    my ($method, $u, $p, $body) = @_;
    my $headers = [];

    if (HTTP09()){
        push @$headers, "${method} $u->{path}", ''; # This is the minimal request (in 0.9)
    } else {
        if ($u->{proxified}){
            push @$headers, "${method} $u->{url} HTTP/${http_vers}"; # via a proxy, request full url
        } else {
            my $path = $u->{path} . ($u->{params} ? "?$u->{params}" : '');
            push @$headers, "${method} ${path} HTTP/${http_vers}"; # else request only the path
        }

        # FIXME: the headers must not be in a hash as we can send repeated headers
        # when they can be also a coma-separated list https://tools.ietf.org/html/rfc7230#section-3.2.2

        # process the custom headers
        my %custom;
        for my $ch (@{$args{header}}){
            # curl man: Remove an internal header by giving a replacement without content
            #           on the right side of the colon, as in: -H "Host:".
            #           If you send the custom header with no-value then its header must be terminated with a semicolon,
            #           such as -H "X-Custom-Header;" to send "X-Custom-Header:".
            if ($ch =~ /^([A-Za-z0-9-]+)([:;])\s*(.*)$/){
                # undef will make header removal
                if ($2 eq ':'){
                    if ($3){
                        $custom{lc $1} = "$1: $3";
                    } else {
                        $custom{lc $1} = undef;
                    }
                } elsif ($2 eq ';'){
                    $custom{lc $1} = "$1:";
                } else {
                    say STDERR "* Unsupported syntax for custom header: '$ch' ignored";
                }
            } else {
                say STDERR "* Unsupported syntax for custom header: '$ch' ignored";
            }
        }

        # we need to pass the port after host only when the port is not the default associated to the protocol
        # see RFC2616 §14.23
        my $hostport = '';      
        if (($u->{scheme} eq 'http') && ($u->{port} != $defports{$u->{scheme}})){
            $hostport = ":$u->{port}";
        }
        push @$headers, "Host: $u->{host}${hostport}" unless exists $custom{host};
        add_http_header($headers, \%custom, 'User-Agent', ${uagent});
        add_http_header($headers, \%custom, 'Accept', '*/*');
        add_http_header($headers, \%custom, 'Connection', 'close');
        my $auth = $args{basic} || $u->{auth};
        add_http_header($headers, \%custom, 'Authorization', 'Basic ' . encode_base64($auth, '')) if $auth;
        add_http_header($headers, \%custom, 'Referer', $args{referer}) if defined $args{referer};
        add_http_header($headers, \%custom, 'Content-Type', $args{content}) if defined $args{content};
        
        if (defined $body){
            if (ref $body eq 'HASH'){
                # if ($body->{kind} eq 'stdin'){
                    add_http_header($headers, \%custom, 'Content-Length', $body->{size});
                    add_http_header($headers, \%custom, 'Content-type', $body->{ctype}) unless defined $args{content};
                # }
            } else {
                add_http_header($headers, \%custom, 'Content-Length', length $body);
                add_http_header($headers, \%custom, 'Content-type', 'application/x-www-form-urlencoded') unless defined $args{content};
            }
        }
        map { push @$headers, $custom{$_} if defined $custom{$_} } keys %custom;
    }

    # Process Cookies - No more than a single header - https://tools.ietf.org/html/rfc6265#section-5.4
    if ($use_cookies){
        my $head = get_matching_cookies($u, $cookies);
        push @$headers, $head if $head;
    }    

    return $headers;
}

# add a header to the custom headers, depending on existing custom headers (if any)
# - set to the default value if not in custom headers
sub add_http_header {
    my ($headers, $custom, $name, $default) = @_;

    my $field = lc $name;
    if (! exists $custom->{$field} ){
        $custom->{$field} = "$name: $default";
    }
}

# When POSTing data, compute length, content-type and data to POST
sub prepare_http_body_to_post{
    my $post = $args{data} || $args{'data-binary'} || $args{'data-raw'};
    if ($post){
        if ($args{'data-raw'}){
            return $args{'data-raw'}; # we do not interpret the @ in raw mode
        } elsif ($post =~ /^@(.*)/){
            if ($1){
                my $fd;
                if ($1 eq '-'){
                    $fd = *STDIN;
                } elsif (-e $1){
                    open $fd, '<', $1 or die "cannot open $1: $!";
                } else {
                    # file does not exist
                    say STDERR "Warning: Couldn't read data from file \"$1\", this makes an empty POST.";
                    return { kind => 'empty',
                             ctype => 'application/x-www-form-urlencoded'
                    };
                }
                my $data;
                if ($args{data}){
                    while (my $l = <$fd>){
                        $l =~ s/[\r\n]+//g;
                        $data .= $l;
                    }
                } elsif ($args{'data-binary'}){
                    my $buf_size = 1024 * 1024;
                    while(my $block = $fd->sysread(my $buf, $buf_size)){
                        # syswrite $OUT, $buf, $block;
                        # $sent += $block;
                        $data .= $buf;
                    }
                }
                close $fd unless fileno($fd) == fileno(STDIN);
                
                return {
                    size => length $data,
                    ctype => 'application/x-www-form-urlencoded',
                    data => $data
                };
            }
        } else {
            return $args{data}; # it's a plain text 
        }        
    } elsif (@{$args{'data-urlencode'}}){
        my @encoded;
        for my $data (@{$args{'data-urlencode'}}){
            $data =~ s/^(\w+)=(.*)/"$1=" . urlencode($2)/e;
            push @encoded, $data;
        }
        return join('&', @encoded);
    } else {
        return undef;
    }
}

sub build_http_proxy_headers {
    my $p = shift;
    my $u = shift;
    my $headers = [];

    if ($u->{scheme} eq 'https'){
        if ($args{proxy10} || HTTP10()){
            push @$headers, "CONNECT $u->{host}:$u->{port} HTTP/1.0";
        } elsif (HTTP11()){
            push @$headers, "CONNECT $u->{host}:$u->{port} HTTP/1.1";
        }
    }
    my $auth = $args{'proxy-user'} || $p->{auth};
    push @$headers, 'Proxy-Authorization: Basic ' . encode_base64($auth) if $auth;
    if (HTTP11()){
        # push @$headers, 'Proxy-Connection: close';
    }
    return $headers;
}

# Given the STDOUT/STDERR of the server or tunnel client
# process the response and returns a hashref with
# - status: hash of {proto, code, message}
# - headers: hash of response headers from server
# - byte_len: the size of the response
# - captured: when performing actions, store the response content in this key
sub process_http_response {
    my ($IN, $ERR, $url_final, $url_proxy, $need_capture) = @_;
    my $headers_done = 0;       # flag to know if we are processing headers or body
    my $status_done = 0;        # flag to know if we have processed the status
    my $received = 0;           # counter for total bytes received
    my $content_length = 0;     # size of response, according to the response header
    my %headers;                # a map for all received headers
    my %resp;                   # response meta-data
    my $capture;                # buffer to print response instead of STDOUT

    # when we receive the server response, we print the result to STDOUT (and possibly the headers)
    # but when we need to process actions (e.g. for pattern matching) we capture output to a memory buffer
    
    # if we need to capture the output, keep the original STDOUT
    my $STDOUT_UNCAPTURED;
    if ($need_capture){
        open $STDOUT_UNCAPTURED, '>&', STDOUT;
        close STDOUT;
        open STDOUT, '>', \$capture or die "Cannot capture output: $!";
    }
    my $selector = IO::Select->new();
    $selector->add($ERR) if $ERR;
    $selector->add($IN);

    say STDERR "* Processing response" if $args{debug};

    # reading loop on both server output and errors, with a timeout
    while (my @ready = $selector->can_read($args{'max-wait'} || $def_max_wait)) {
        foreach my $fh (@ready) {
            if ($ERR && (fileno($fh) == fileno($ERR))) {
                my $line = <$fh>;
                $line =~ s/[\r\n]+$//;
                say STDERR "* proxy/tunnel STDERR: $line" if $args{debug};
                if ($url_final->{tunneled} && ($line =~ /^s_client: HTTP CONNECT failed: (\d+) (.*)/)){
                    my $err_txt = sprintf("Received '%d %s' from tunnel after CONNECT", $1, $2);
                    say STDERR $err_txt;
                    exit 5;
                }
            } elsif (fileno($fh) == fileno($IN)) {
                say STDERR "* processing STDIN" if $args{debug};
                if (! $headers_done && !HTTP09()){ # there is no header in HTTP/0.9
                    # local $/ = "\r\n";
                  HEAD: while(defined (my $line = <$IN>)){
                      $received += length($line);
                      $line =~ s/[\r\n]+$//;
                      say STDERR '< ', $line if $args{verbose} || $args{debug};
                      say STDOUT $line if !$need_capture && $args{head} || $args{'include-response'};
                      if ($line =~ /^$/){
                          $headers_done++;
                          last HEAD;
                      }
                      if (!$status_done && $line =~ m{^([^\s]+) (\d+) (.*)$}){
                          # this is the response status
                          $resp{status}{proto} = $1;
                          $resp{status}{code} = $2;
                          $resp{status}{message} = $3;
                          $status_done++;
                      }
                      if ($line =~ /^([A-Za-z0-9-]+):\s*(.*)$/){
                          # this is a header
                          my $hname = lc $1;
                          my $hvalue = $2;
                          if ($hname eq 'set-cookie'){
                              my @head_cookies = parse_cookie_header($hvalue, $url_final);
                              say STDERR "Cannot parse cookie header: $hvalue" unless @head_cookies;
                              HCOOKIE: for my $hcook (@head_cookies){
                                  # replace identical cookies
                                  for (my $c = 0; $c <= $#{$cookies}; $c++){
                                      if ($cookies->[$c]->{domain} eq $hcook->{domain}
                                          && $cookies->[$c]->{path} eq $hcook->{path}
                                          && $cookies->[$c]->{name} eq $hcook->{name}){
                                          say STDERR "Replacing cookie ".$hcook->{name} if $args{debug};
                                          splice @$cookies, $c, 1, $hcook;
                                          next HCOOKIE;
                                      }
                                  }
                                  # if we arrive here, the cookie was not found, add it
                                  say STDERR "Adding cookie ".$hcook->{name} if $args{debug};
                                  push @$cookies, $hcook;
                              }
                          }

                          if (exists $headers{$hname}){
                              # header fields can be extended over multiple lines
                              # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2
                              if (ref $headers{$hname} eq 'ARRAY'){
                                  # already an array ref, add item
                                  push @{$headers{$hname}}, $hvalue;
                              } else {
                                  # replace the single item by an array ref of previous value + new item
                                  $headers{$hname} = [ $headers{$hname}, $hvalue ];
                              }
                          } else {
                              # most of headers are single values
                              $headers{$hname} = $hvalue;
                          }
                      }                            
                  }
                } # end of headers processing
                # we show body contents only when not following redirects
                my $is_redirected = $resp{status} && $resp{status}{code} && $resp{status}{code} =~ /^3/;
                say STDERR "* Ignoring the response-body" if ($is_redirected && $args{location}) && (! $fh->eof ) && ($args{verbose} || $args{debug});
                binmode(STDOUT, ":raw"); # pass in raw layer to prevent utf8 or cr/lf conversion in binary files
                unless ($fh->eof){ # loop on the remaining of response
                    $content_length = $headers{'content-length'};
                    if ($content_length){
                        say STDERR "* need to read $content_length bytes in response..." if $args{debug};
                    } else {
                        say STDERR "* Unknown size of response to read..." if $args{debug};
                    }
                    my $buf_size = 2 * 1024 * 1024;
                    my $block = $fh->read(my $buf, $buf_size);
                    if ($block){
                        say STDERR "* Read $block bytes" if $args{debug};
                        $received += $block;
                        print STDOUT $buf unless ($is_redirected && $args{location});
                    }
                }
                # there may have additional info... (body > Content-Length)
            };
            
            if (eof($fh)){
               say STDERR "* Nothing left in the filehandle $fh" if $args{debug};
               $selector->remove($fh);
            }
        }
    }
    $resp{headers} = \%headers;
    $resp{byte_len} = $received; # keep the size of read data
    if ($need_capture){
        # restore the output to the original value before capture
        say STDERR sprintf("* Captured %d bytes:\n%s", length $capture, $capture) if $args{verbose} || $args{debug};
        $resp{captured} = \$capture;
        close STDOUT;
        open (STDOUT, '>&', $STDOUT_UNCAPTURED);
    }
    say STDERR "Parsed cookies: ", Dumper $cookies if $args{debug};
    say STDERR "* end of response" if $args{debug};
    return \%resp;
}

# Build the value of a Cookie: header containing the cookies
# suitable for the given url
sub get_matching_cookies {
    my ($url, $cookies) = @_;
    return () unless @$cookies;
    my $udomain = $url->{host};
    my $upath = $url->{path};
    my @matching;
    for my $cookie (@$cookies){
        next if $cookie->{secure} && !($url->{scheme} eq 'https'); # secure cookies are only for https
        my $dom_rx = $cookie->{domain} =~ s/\./\\./gr;
        $dom_rx = "\\b${dom_rx}\$";
        my $path_rx = '^' . $cookie->{path} . '\b';
        if (($udomain =~ /$dom_rx/) || ($cookie->{domain} eq '*') && ($upath =~ /$path_rx/)){
            push @matching, $cookie;
        }
    }
    my $txt = join '; ', map { "$_->{name}=$_->{value}" } @matching;
    return $txt ? "Cookie: ${txt}" : undef;
}

# Return the list of cookie definitions contained in a Set-Cookie header
sub parse_cookie_header {
    my ($head_val, $url) = @_;
    # the local our fixes the Warning: 'Variable "%months" will not stay shared at (re_eval 22) line 2.'
    # because the $rx captures the %months variable, but a different $rx is built every time the function may be called
    # https://stackoverflow.com/a/19454419/317266
    local our %months = ( Jan=>0, Feb=>1, Mar=>2, Apr=>3, May=>4, Jun=>5, Jul=>6, Aug=>7, Sep=>8, Oct=>9, Nov=>10, Dec=>11 );
    my $cookies;
    my $rx = qr{
    # NOTES:
    # this regex is a recursive descent parser - see https://www.perlmonks.org/?node_id=995856
    # and chapter 1 "Recursive regular expressions" of Mastering Perl (Brian d Foy)
    #
    # Inside the block (?(DEFINE) ...)  (?<FOOBAR> ...) defines a named pattern FOOBAR
    #                                   that can be called with (?&FOOBAR)
    # (?{ ... }) is a block of Perl code that is evaluated at the time we reach it while running the pattern
    # $^R is the value returned by the last runned (?{ }) block
    # $^N is the last matched group

    (?&LIST) (?{ $_ = $^R->[1] })

    (?(DEFINE)                      # define some named patterns to call with (?&RULENAME)
    
      (?<LIST>
       (?{ [ $^R, [] ] }) # initialize an array ref for the list of cookies
       (?&COOKIE)           (?{ [ $^R->[0][0], [ $^R->[1] ] ] }) # fill the first cookie in the list
       (?:
        \s* , \s* (?&COOKIE) (?{ [ $^R->[0][0], [ @{$^R->[0][1]}, $^R->[1] ] ] }) # append a new cookie to the list
       )*
      )
      
      (?<COOKIE>
       (?{ [ $^R, {} ] }) # initialize an href for the content of the cookie
       # at least we have a key=value
       (?&KV)             (?{ [ $^R->[0][0], { %{ $^R->[0][1] }, name=>$^R->[1], value=>$^R->[2] } ] })
       ( ; \s    # but we can have additional attributes
         ( 
           (?&SINGLEATTR) (?{ [ $^R->[0][0], { %{ $^R->[0][1] }, lc $^R->[1] => 1 } ] })
          |(?&KV)         (?{ [ $^R->[0][0], { %{ $^R->[0][1] }, lc $^R->[1] => $^R->[2] } ] })
         )
       )*
      )
      
      (?<KV> # a pair key=value
       (?&KEY) = (?&VALUE) (?{ [$^R->[0][0], $^R->[0][1], $^R->[1]] })
      )
      
      (?<KEY> # cookie attributes that have a value
       ( [^;,= ]+ ) #| expires | domain | path | max-age | samesite ) 
       (?{ [ $^R, $^N ] })
      )
      
      (?<SINGLEATTR> # cookie attribute that do not accept value
       ( HttpOnly | Secure )  (?{ [ $^R, $^N ] })
      )
      
      (?<VALUE> # get the value for a key with special handling of dates
       (?: (?&EXPIRES) | (?&STRING) )
      )
      
      (?<EXPIRES> # legal format = Wdy, DD-Mon-YYYY HH:MM:SS GMT
                                 # RFC 822, 850, 1036, 1123, with only GMT time zone 
                                 # and date separators must be dashes
                                 # but I have seen 
                                 # Tue, 2 Mar 2021 21:27:55 GMT
                                 # Tue, 03 Mar 2020 00:27:55 GMT
       \w\w\w , \s (?<DAY>\d?\d) [- ] (?<MONTH>\w\w\w) [- ] (?<YEAR>(?:\d\d)?\d\d)
       \s (?<HOUR>\d\d) : (?<MINUTE>\d\d) : (?<SECOND>\d\d) \s GMT 
       (?{ #printf STDERR "parsed date: %s %s %s %s %s %s\n", $+{SECOND}, $+{MINUTE}, $+{HOUR}, $+{DAY}, $+{MONTH}, $+{YEAR};
           [ $^R, timelocal( $+{SECOND}, $+{MINUTE}, $+{HOUR}, $+{DAY}, $months{$+{MONTH}}, ($+{YEAR} < 100 ? $+{YEAR} + 2000 : $+{YEAR}) ) ] })
      )
      
      (?<STRING>
       ([^;,]*) (?{ [$^R, $^N] })
      )
    
    ) # end of DEFINE set
    }xims;
    {
        local $_ = shift;
        local $^R;
        eval { m{$rx}; } and $cookies = $_;
    }
    if ($cookies){
        say STDERR Dumper $cookies if $args{debug};
        # sanitize cookies: without domain or path, use url current values
        for my $c (@$cookies){
            $c->{domain} = $url->{host} unless $c->{domain};
            $c->{path} = $url->{path} unless $c->{path};
            if ($c->{'max-age'}){
                # max-age should always take precedence on Expires (if any)
                $c->{expires} = time + $c->{'max-age'};
            }
        }
    }
    return $cookies ? @$cookies : ();
}

# Load cookies given on the command line
# we only support one occurrence of the --cookie parameter
sub load_commandline_cookies {
    my $arg = shift;
    my @jar;
    while ($arg =~ /(\w+)=([^; ]*)/g){
        my $cookie = {};
        $cookie->{name} = $1;
        $cookie->{value} = $2;
        $cookie->{domain} = '*';
        $cookie->{path} = '/';
        push @jar, $cookie;
    }
    return \@jar;
}

# Load cookies from the cookie-jar file
# The cookie jar is either in Netscape format
# or in Set-Cookie header format
sub load_cookie_jar {
    my $file = shift;
    my @jar;
    open my $in, '<', $file or die "Cannot open cookie-jar '$file': $!";
    my $header_done = 0;
    while (defined (my $line = <$in>)){
        chomp $line;
        # TODO: add the support for http headers format
        next if $line =~ /^#/ && !$header_done;
        $header_done++ and next if $line =~ /^$/ && !$header_done;
        if ($line =~ /^([^\t]+)\t([^\t]+)\t([^\t]+)\t([^\t]+)\t([^\t]+)\t([^\t]+)\t([^\t]+)$/){
            my $cookie = {};
            $cookie->{tailmatch} = $2 eq 'TRUE';
            $cookie->{path} = $3;
            $cookie->{secure} = $4 eq 'TRUE';
            $cookie->{expires} = $5; # legal format = Wdy, DD-Mon-YYYY HH:MM:SS GMT, if undef, it's a session cookie
            $cookie->{name} = $6;
            $cookie->{value} = $7;
            $cookie->{domain} = $1; # do this as last because of next match that resets the vars $1..$7
            if ($cookie->{domain} =~ /^#HttpOnly_(.*)/){
                $cookie->{domain} = $1;
                $cookie->{httponly} = 1;
            }
            push @jar, $cookie;
        }
    }
    close $in;
    return \@jar;
}

# Save the cookie in the Netscape format
# this format is also supported by cURL
sub save_cookie_jar {
    my ($file, $cookies) = @_;
    return unless @$cookies; # emulate curl: do nothing if encountered no cookie
    say STDERR scalar(@$cookies) . " cookie(s) to save in jar $file";
    my $out;
    if ($file eq '-'){
        $out = *STDOUT;
    } else {
        open $out, '>', $file or do { say STDERR "* WARNING: failed to save cookies in $file"; return}; # emulate curl
    }
    print $out <<HEADER;
# Netscape HTTP Cookie File
# https://curl.haxx.se/docs/http-cookies.html
# This file was generated by $uagent! Edit at your own risk.

HEADER
    for my $cookie (@$cookies){
        say $out sprintf ("%s\t%s\t%s\t%s\t%s\t%s\t%s",
                          $cookie->{httponly} ? '#HttpOnly_' . $cookie->{domain} : $cookie->{domain},
                          $cookie->{tailmatch} ? 'TRUE' : 'FALSE',
                          $cookie->{path},
                          $cookie->{secure} ? 'TRUE' : 'FALSE',
                          $cookie->{expires} // 0,
                          $cookie->{name},
                          $cookie->{value});
    }
    close $out unless $file eq '-';
}

# prepare the action handler(s)
sub parse_process_action {
    my $param = shift;
    my $action;
    if ($param =~ /^(\w+):(.*)/){
        my $type = $1;
        my $param = $2;
        if ($type eq 'header'){
            $action = { action => 'print', args => { what => 'header', value => $2 } };
        } elsif ($type eq 'bodyrx'){
            $action = { action => 'grep', args => { what => 'body', value => $2 } };
        } elsif ($type eq 'json'){
            $action = { action => 'print', args => { what => 'json', value => $2 } };
        }
    } # else {} parse json
    say STDERR "Procession action:" . Dumper $action if $args{debug};
    return $action;
}

# Do something with the retrieved resource
sub perform_action {
    my ($action, $resp) = @_;
    if (lc $action->{action} eq 'print'){
        if ($action->{args}{what} eq 'header'){
            say STDOUT $resp->{headers}{lc $action->{args}{value}};
        } elsif ($action->{args}{what} eq 'json'){
            my $js = from_json(${$resp->{captured}});
            if ($js){
                # say Dumper $js;
                my $jp = $action->{args}{value};
                my $jval = get_jpath($js, $jp);
                say STDOUT $jval;
            } else {
                say STDERR "Request did not returned a valid JSON for an action.";
                exit 7;
            }
        }
    } elsif (lc $action->{action} eq 'grep'){
        if ($action->{args}{what} eq 'body'){
            if (${$resp->{captured}} =~ /$action->{args}{value}/){
                say STDOUT $&;
            }
        }
    }
}

sub TRACE_JSON {
    return $args{'debug-json'} ? 1 : 0;
}

my @eval_stack; my $trace_indent; my $object_count;
sub json_trace  { return unless -t STDERR; say STDERR ' ' x $trace_indent, @_ if TRACE_JSON}
sub dump_stack  { json_trace $_ for ("stack is -----", scalar(@eval_stack) . ' =>' . Dumper(\@eval_stack), '-----') }
sub push_val    { push @eval_stack, shift; }
sub peek_val    { my @idx = @_; @idx=(-1) unless @idx; return @eval_stack[ @idx ]; }
sub pop_val     { return pop @eval_stack; }
sub add_obj_val { my ($k,$v) = @_; $eval_stack[-1]->{$k} = $v; }
sub add_arr_val { my $v = shift; push @{$eval_stack[-1]}, $v; }
sub eval_json_string {
    my $s = shift;
    $s =~ s/\\u([0-9A-Fa-f]{4})/\\x{$1}/g;
    $s =~ s/([@\$*%])/\\$1/g;            # prevent interpolation of sigils
    return eval $s;
}

# Return a Perl structure corresponding to a json string
sub from_json {
    @eval_stack = ();
    $trace_indent = 0;
    $object_count = 0;
    
    my $rx = qr{
    # NOTES:
    # this regex is a recusrive descent parser - see https://www.perlmonks.org/?node_id=995856
    # and chapter 1 "Recursive regular expressions" of Mastering Perl (Brian d Foy)
    #
    # Inside the block (?(DEFINE) ...)  (?<FOOBAR> ...) defines a named pattern FOOBAR
    #                                   that can be called with (?&FOOBAR)
    # (?{ ... }) is a block of Perl code that is evaluated at the time we reach it while running the pattern
    # $^R is the value returned by the last runned (?{ }) block
    # $^N is the last matched group

    (?&VALUE) (?{ $_ = pop_val() }) # <== entry point of the parser
    
    (?(DEFINE) # this does not try to match, it only defines a serie of named patterns
    
      (?<VALUE> (?{ json_trace 'value?' })
        \s*+
        (
         (?{ $trace_indent++; })
         (?&STRING)
         |
         (?&NUMBER)
         |
         true  (?{ push_val(1); json_trace '->true' })
         |
         false (?{ push_val(0); json_trace '->false' })
         |
         null  (?{ push_val(undef); json_trace '->null' })
         |
         (?&ARRAY)
         |
         (?&OBJECT)
        )
        \s*+
        (?{ $trace_indent--; })
        (?{ json_trace '->value'; dump_stack() if TRACE_JSON && -t STDERR })
      )
    
      (?<OBJECT> # will generate a Perl hash
        (?{ json_trace "try object" })
        \{ # start of object
          (?{ push_val({}); $trace_indent++; })  # init structure
          \s*+
          (?: 
            (?&KV) # first pair
            (?{ 
               my $v = pop_val(); my $k = pop_val(); add_obj_val($k, $v);
               json_trace '->pair';
            })      
            (?: # additional pairs 
            \s*+ , \s*+ (?&KV)
             (?{ 
                 my $v = pop_val(); my $k = pop_val(); add_obj_val($k, $v);
               json_trace '->pairN';
             })
            )* # additional pairs are optional
          )? # object may be empty
          \s*+
        \}  # end of object
        (?{ $trace_indent--; $object_count++; say STDERR "$object_count objects" if $object_count % 10 == 0 and TRACE_JSON; json_trace "->object " . Dumper(peek_val()) })
      )
    
      (?<KV>  # tuple <key, value>
        (?{ json_trace 'try tuple' })
        (?&STRING)
        (?{ json_trace 'key done' })
        \s*+ : \s*+ 
        (?{ json_trace 'try tuple value' })
        (?&VALUE)
        (?{ json_trace '->tuple ', Dumper(peek_val(-2,-1)) })
      )
    
      (?<ARRAY> # will generate a Perl array
        (?{ json_trace "try array" })
        \[ # start of array
          (?{ push_val([]) })  # init structure
          \s*+
          (?: 
            (?&VALUE)   # first element 
            (?{  my $v = pop_val(); add_arr_val( $v )
            })
            (?: # additional elements
            \s*+ , \s*+ (?&VALUE) # additional elements
             (?{
                 my $v = pop_val(); add_arr_val( $v )
             })
            )* # additional elements are optional
          )? # array may be empty
          \s*+
        \] # end of array
        (?{ json_trace "->array " . Dumper(peek_val()) })
      )
    
      (?<STRING>
        (?{ json_trace "try string" })
        (
          "
          (?:
            [^\\"]+
          |
            \\ ["\\bfnrt]  # escaped backspace, form feed, newline, carriage return, tab, \, "
          |
            \\ u [0-9a-fA-F]{4} 
          )*
          "
        )
        (?{ 
            my $v = eval_json_string($^N); 
            push_val($v);
            json_trace sprintf('->string "%s"', peek_val());
        })
      )
    
      (?<NUMBER>
        (?{ json_trace "try number" })
        (
          -?
          (?: 0 | [1-9]\d* )
          (?: \. \d+ )?
          (?: [eE] [-+]? \d+ )?
        )
        (?{ my $v = eval $^N;
            push_val($v);
            json_trace "->number $v"; 
        })
      )
    
    ) #DEFINE
    }xms;
    my $struct;
    {
        local $_ = shift;
        # we do not use $^R anymore
        # local $^R;
        eval { m{\A$rx\z}; } and $struct = $_;
    }
    return $struct;
}

sub to_json {
    my $data = shift;
    # return 'expecting a hashref as input' unless ref $h eq 'HASH';

    my $j;
    if (!defined $data){
        $j = "null";
    } elsif (ref $data eq 'HASH'){
        my @items;
        for my $k (keys %$data){
            my $v = $data->{$k};
            my $c = to_json($v);
            push @items, '"' . $k . '":' . $c;
        }
        $j = '{' . join(',', @items) . '}';
    } elsif (ref $data eq 'ARRAY'){
        my @items;
        (push @items, to_json($_)) for @$data;
        $j = '[' . join(',', @items) . ']';
    } elsif ($data =~ /^-?\d+(\.\d+)?([eE][+-]?\d+)?$/){
        $j = eval $&; # $& = last successful match
    } elsif ($data =~ /true/i){
        $j = "true";
    } elsif ($data =~ /false/i){
        $j = "false";
    } else {
        # return a string while escaping some chars
        $data =~ s/([\\"])/\\$1/g; 
        $data =~ s/[\n]/\\n/g;
        $data =~ s/[\r]/\\r/g;
        $data =~ s/[\b]/\\b/g;
        $data =~ s/[\f]/\\f/g;
        $data =~ s/[\t]/\\t/g;
        # $data =~ s/([\x00-\x1f]|[\x7f-\x{ffff}])/sprintf('\u%04x', ord($1))/eg; # for unicode chars
        $j = '"' . $data . '"';
    }
    return $j;
}

# get a value from a structure using an xpath-like
# can be a scalar or a complex struct
# in case of complex struct, return the jsonification   
sub get_jpath {
    my ($ref, $path, $fullpath) = @_;
    unless (ref $path eq 'ARRAY'){
        $fullpath = $path;              # keep a copy of initial path for reference in errors
        $path = [ split /\//, $path ] ; # for first call path is not an array ref
    }
    print STDERR "Path: " . join(' / ', @$path) . "\n" if $args{debug};
    my $p = shift @$path;       # next element to get from path
    my $v;                      # placeholder for data
    if (ref $ref eq 'ARRAY'){
        if ($p =~ /\[(\d*)\]/){ # we try to access by index
            my $index = eval $1;
            die "eval issue of `$1`: ".$@ if $@;
            if (defined $index && $index ne ''){
                die sprintf("Index '%s' is greater than max index of array (%d) in path '%s'", $p, scalar(@$ref)-1, $fullpath) if $index >= scalar @$ref;
                $v = @{$ref}[$index];
                return get_jpath($v, $path, $fullpath) if @$path;
            } else {
                   # for empty squared brackets, return whole array or process function
                if (@$path){
                    return get_jpath($ref, $path, $fullpath);
                } else {
                    $v = $ref;
                }
            }
        } elsif ($p eq 'length()'){
            return scalar @$ref; # pseudo function for size of array
        } else {
            die "Array is not accessible with '$p' in path '$fullpath'" if $p; # non-numeric index
            # return t
            $v = $ref;
        }
    } elsif (ref $ref eq 'HASH'){
        if ($p){
            # we still have a remaining path
            if (exists $ref->{$p}){
                $v = $ref->{$p};
                return get_jpath($v, $path, $fullpath) if @$path;
            } elsif ($p eq 'length()'){
                return scalar keys %$ref; # pseudo function for number of keys in object
            } else {
                die Dumper($ref) . "object does not contain '$p' in path '$fullpath'";
            }            
        } else {
            # no more path, return the object
            $v = $ref;
        }
    }
    if (ref $v){
        return to_json($v);     # we are pointing to a complex value, jsonify it
    } else {
        return $v;              # return the single value
    }
}    
    
sub process_stomp {
    my $url_final = shift;
    my ($IN, $OUT, $ERR, $host, $port, $resp);
    ($OUT, $IN, $ERR) = connect_direct_socket($url_final->{host}, $url_final->{port});

    my ($user, $passwd) = ('guest', 'guest');
    my $connect = [ 'CONNECT', "login:${user}", "passcode:${passwd}"];
    send_stomp_request($OUT, $IN, $connect);
    $resp = process_stomp_response($IN);
    if ($resp->{command} eq 'CONNECTED'){
        my $body = $args{stompmsg};
        my $len = length($body);
        my $type = 'text/plain';
        send_stomp_request($OUT, $IN, [ 'SEND', "destination:$url_final->{path}", "content-type:${type}", "content-length:${len}" ], $body );
        # this is blocking...
        $resp = process_stomp_response($IN);
    }
    close $IN;
    close $OUT;
    close $ERR if $ERR;
}

sub send_stomp_request {
    my ($OUT, $IN, $headers, $body) = @_;
    if ($args{verbose}){
        say STDOUT "> $_" for @$headers;
    }
    my $request = join( "\n", @$headers ) . "\n\n" . ($body || '') . "\000";
    print $OUT $request;
}

sub process_stomp_response {
    my $IN = shift;
    my $selector = IO::Select->new();
    $selector->add($IN);
    my %frame;
    
    while (my @ready = $selector->can_read($args{'max-wait'} || $def_max_wait)) {
        foreach my $fh (@ready) {
            if (fileno($fh) == fileno($IN)) {
                my $buf_size = 1024 * 1024;
                my $block = $fh->sysread(my $buf, $buf_size);
                if($block){
                    if ($buf =~ s/^\n*([^\n].*?)\n\n//s){
                        my $headers = $1;
                        for my $line (split /\n/,  $headers){
                            say STDOUT "< $line" if $args{verbose} || $args{debug};
                            if ($line =~ /^(\w+)$/){
                                $frame{command} = $1;
                            }
                            if ($line =~ /^([^:]+):(.*)$/){
                                $frame{headers}{$1} = $2;
                            }
                        }
                        if ($frame{headers}{'content-length'}){
                            if (length($buf) > $frame{headers}{'content-length'}){
                                $frame{body} = substr($buf, 0, $frame{headers}{'content-length'}, '');
                            }
                        } elsif ($buf =~ s/^(.*?)\000\n*//s ){
                            $frame{body} = $1;
                        }
                    }
                }
                # $selector->remove($fh) if eof($fh);
            }
        }
    }
    return \%frame;
}

# Extract the differents parts from an URL
# return a hashref or undef if it fails
# this uses a extended regex as a recursive descent parser    
sub parse_url {
    my $given = shift;
    unless( $given =~ qr{
        (?: (?<SCHEME> [\w]+ ) : )?
        (?: 
          (?: // )?
          (?: (?<AUTH> (?<USER> (?&UNRESERVED)+) (?: : (?<PWD>[^@]+) )? ) @ )?
          (?<HOST> [^-/] (?&UNRESERVED)+ )
          (?: : (?<PORT> \d+ ))?
        )?
        (?<PATH> (?&PCHAR)+ )?
        (?: \? (?<PARAMS> (?&PCHAR)* ))?
      
        (?(DEFINE) #from here, define some sub-parts
          (?<PCHAR> (?&UNRESERVED) | (?&PCTENCODED) | (?&SUBDEL) | : | @ )
          (?<PCTENCODED> % (?&HEXDIG) (?&HEXDIG) )
          (?<HEXDIG> [0-9A-Za-z] )
          (?<UNRESERVED> [A-Za-z0-9._~-] )
          (?<SUBDEL> [/!\$'&()\*\+,\.=] )
        )
            }x ){
        return undef;
    }
    my $url = {};
    $url->{url} = $given;
    $url->{scheme} = $+{SCHEME} || 'http';
    if ($+{AUTH}){
        $url->{auth} = {
            user => $+{USER},
            $+{PWD} ? (password => $+{PWD}) : ()
        };
    }
    $url->{host} = $+{HOST};
    $url->{port} = $args{port} || $+{PORT};
    unless ($url->{port}){
        if ($url->{scheme} eq 'http'){
            $url->{port} = 80;
        } elsif ($url->{scheme} eq 'https'){
            $url->{port} = 443;
        } elsif ($url->{scheme} eq 'stomp'){
            $url->{port} = 61613;
        } elsif ($url->{scheme} eq 'file'){
            # no need for port for local file access
            # delete $url->{port};
#        } elsif ($url->{scheme} eq 'dict'){
#            $url->{port} = 2628;
        } else {
            say STDERR "Default port unknown for scheme '$url->{scheme}'...";
            return undef;
        }
    }
    $url->{path} = $+{PATH} || '/';
    if ($url->{scheme} eq 'file' && $url->{path} =~ m{^///}){
        $url->{path} = substr($url->{path}, 2);
    }
    $url->{params} = $+{PARAMS};
    if ($args{debug}){
        say STDERR "* Parsed URL '$given'";
        say(STDERR "*  $_ = " . (defined $url->{$_} ? $url->{$_} : "undef")) for(sort(keys %$url));
    }
    return $url;
}

# perform a string encoding compatible with url
sub urlencode {
    my $s = shift;
    $s =~ s/([^A-Za-z0-9])/sprintf("%%%02X", ord($1))/eg;
    return $s;
}

# decode an url-encoded string
sub urldecode {
    my $s = shift;
    $s =~ s/\+/ /g;
    $s =~ s/%(..)/pack('c', hex($1))/eg;
    return $s;
}

# tell if we requested HTTP v0.9
sub HTTP09 {
    return ($http_vers && $http_vers eq '0.9') ? 1 : undef;
}

# tell if we requested HTTP v1.0
sub HTTP10 {
    return ($http_vers && $http_vers eq '1.0') ? 1 : undef;
}

# tell if we requested HTTP v1.1
sub HTTP11 {
    return ($http_vers && $http_vers eq '1.1') ? 1 : undef;
}

# creation of a direct socket connection 
sub connect_direct_socket {
    my ($host, $port) = @_;
    my $sock = new IO::Socket::INET(PeerAddr => $host,
                                    PeerPort => $port,
                                    Proto    => 'tcp') or die "Can't connect to $host:$port\n";
    if ($args{'tcp-nodelay'}){
        $sock->setsockopt(IPPROTO_TCP, TCP_NODELAY, 1);
        say STDERR "* TCP_NODELAY set" if $args{verbose} || $args{debug};
    }
    $sock->autoflush(1);
    say STDERR "* connected to $host:$port" if $args{verbose} || $args{debug};
    
    return $sock, $sock, undef;
}

# for HTTPS, we are "cheating" by creating a tunnel with OpenSSL in s_client mode
sub connect_ssl_tunnel {
    my ($dest, $proxy) = @_;
    my ($host, $port, $phost, $pport);
    $host = $dest->{host};
    $port = $dest->{port};
    if ($proxy){
        $phost = $proxy->{host};
        $pport = $proxy->{port};
    }
    my $cmd = "openssl s_client -connect ${host}:${port} -servername ${host} -quiet";# -quiet -verify_quiet -partial_chain';
    $cmd .= " -proxy ${phost}:${pport}" if $phost;
    $tunnel_pid = open3(*CMD_IN, *CMD_OUT, *CMD_ERR, $cmd);
    say STDERR "* connected via OpenSSL to $host:$port" if $args{verbose} || $args{debug};
    say STDERR "* command = $cmd" if $args{debug};

    $SIG{CHLD} = sub {
        print STDERR "* REAPER: status $? on ${tunnel_pid}\n" if waitpid($tunnel_pid, 0) > 0 && $args{debug};
    };
    return *CMD_IN, *CMD_OUT, *CMD_ERR;
}

# poor man's hex dumper :)
sub hexdump {
    my $data = shift;
    my $data_len = shift || 16;
    my $ascii_only = shift || 0;
    my $hex_len = $data_len * 3;
    my $addr = 0;
    my @out;
    for my $s (unpack("(a${data_len})*", $data)){
        last unless $s;
        my $h = join' ', unpack('(H2)*', $s);
        $s =~ s/[\x00-\x1f]/./g;
        $s =~ s/[\x80-\xff]/./g if $ascii_only;        
        push @out, sprintf("%06x  %-${hex_len}s %s", $addr, $h, $s);
        $addr += length($s);
    }
    return @out;
}


__END__

=head1 NAME

pCurl - A minimalist cURL in Perl.

=head1 VERSION

v0.7.3

=head1 SYNOPSIS

pcurl.pl [options] [url]

=head1 DESCRIPTION

pCurl is a vanilla Perl tool that mimics cURL without external dependancies but OpenSSL in the case of a SSL connection. It is intented to provide a subset of cURL when cURL is not available. It is designed to work with a fresh installation of Perl without the need for additional CPAN packages.

=head1 OPTIONS

=over 4

=item --accept <mime type>

Specify an accepted MIME type. This is simply a shortcut for -H 'Accept: your/type'. Default is */*.

=item --action <spec>

Perform an action on the response. It can be the display of a value (from header, regex on body, json path).

=item --basic <user:password>

Use basic http authentication. Sepcified in the form user:password it is passed to the server in Base64 encoding.

=item --content <content-type>

Specify the request content-type. This is simply a shortcut for -H 'Content-Type: your/type'. It can overrides automatic content-type for POSTed data.

=item -b, --cookie <string or file>

Activate cookie support and read cookie from a string like 'NAME=Value' or a file. The file is either in 'HTTP headers format' or in 'Netscape cookie format'. See the L<Unofficial cookie FAQ|http://www.cookiecentral.com/faq/#3.5>. The file is never modified. If you want to save cookies, see --cookie-jar.

=item -c, --cookie-jar <file or dash>

Save cookies into a 'Netscape cookie format' file, or if the given file is '-', output the cookies into STDOUT.

=item -d, --data, --data-ascii <data>

Define some data that will be POSTed to the server. If data starts with '@', the rest of the string will be taken as a file name whose content will be send as request body. If using '-' as file name, the data will be read from standard input (so you can pipe it from another command). Note that CR+LF characters will be discarded from the output. See --data-binary if you need to send unaltered data.

=item --data-binary <data>

Similar to --data, but do not discard CR+LF characters. When reading from a file, perform binary read.

=item --data-raw <data>

Similar to --data, but do not interpret an initial '@' character.

=item --data-urlencode <data>

Similar to --data-raw, but the data will be url-encoded.

=item -I, --head

Show the document headers only. The shorthand notation for -X HEAD.

=item -H, --header <header_spec>

Send an additional header, or change / discard a default one. Usual syntax is -H 'header_name: value', e.g. -H 'X-my-header: some text'. To send several custom headers, repeat the -H parameter. If you pass only 'header_name:' (without value) the header will not be transmitted. If you need to send an empty header, use 'header_name;' (use semicolon).

=item -h, --help

Display a short help.

=item --http09, --http10, --http11

Specify the version of HTTP we want to use. In HTTP/0.9 the only method is GET <url> (without version) and the answer does not return headers, only the body of returned resource. In HTTP/1.0 we can use Host:, Connection: and additional headers. IN HTTP/1.1 the Host: is mandatory and if you do not specify Connection: it is kept open by default. We send automatically a Connection: close by default.

=item -i, --include, --include-response

Include the response headers in the output.

=item --include-request

Include the request headers in the output.

=item --junk-session-cookies

When using -b, --cookie and loading cookies from file, purge the session cookies (those with no expire date).

=item -L, --location

Follow HTTP redirects.

=item --man

Display the full manual.

=item --max-wait <seconds>

Specify the timeout in seconds when waiting for a response. Default is 10s.

=item --max-redirs <number>

Specify the maximum number of redirects to follow. Default is 50.

=item --noproxy <domain_list>

Define a coma-separated list of domains that ignore the proxy. 

=item -o, --output <file>

Write to file instead of stdout.

=item --port <port>

Specify explicitly the port. If not used, we use the port from the url (if specified), or we will try well-known port 80 for HTTP and 443 for HTTPS, depending on the url scheme.

=item -x, --proxy <proxy_url>

Set the url of the HTTP/1.1 proxy to use.

=item --proxy10 <proxy_url>

Set the url of the HTTP/1.0 proxy to use.

=item -U, --proxy-user <user:passwd>

Set the proxy authentication. Only Basic Auth is supported.

=item -e, --referer <referer url>

Specify a string for the referer. If followed by ";auto", when following redirections, reuse the previous url as referer. ";auto" can also be used alone with redirections.

=item -O, --remote-name

Write output to a file named as the remote file (that name is extracted from the URL).

=item -X, --request <method>

Specify the method for the request. Common methods are GET, HEAD, POST, PUT, TRACE, OPTIONS and DELETE, but you can specify a custom method. If not specified, we send a GET. 

=item --stompmsg <message>

Content of the message for the STOMP message broker. Use with a stomp://server:port/queuename url. 

=item --url <url>

Specify explicitly the url. If that parameter is not used, we try to get the url as the remaining text after the parameters.

=item -A, --user-agent <ua string>

Specify a string for User-Agent. If not specified the default User-Agent is 'pcurl v$VERSION'.

=item -v, --verbose

Show both headers during the communication.

=back

=cut

# Local Variables: 
# coding: utf-8-unix
# mode: perl
# tab-width: 4
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 sts=4 et :
